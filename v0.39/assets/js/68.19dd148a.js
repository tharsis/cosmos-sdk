(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{856:function(e,t,a){"use strict";a.r(t);var n=a(1),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"adr-004-split-denomination-keys"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#adr-004-split-denomination-keys"}},[e._v("#")]),e._v(" ADR 004: Split Denomination Keys")]),e._v(" "),a("h2",{attrs:{id:"changelog"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#changelog"}},[e._v("#")]),e._v(" Changelog")]),e._v(" "),a("ul",[a("li",[e._v("2020-01-08: Initial version")]),e._v(" "),a("li",[e._v("2020-01-09: Alterations to handle vesting accounts")]),e._v(" "),a("li",[e._v("2020-01-14: Updates from review feedback")])]),e._v(" "),a("h2",{attrs:{id:"context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[e._v("#")]),e._v(" Context")]),e._v(" "),a("p",[e._v("With permissionless IBC, anyone will be able to send arbitrary denominations to any other account. Currently, all non-zero balances are stored along with the account in an "),a("code",[e._v("sdk.Coins")]),e._v(" struct, which creates a potential denial-of-service concern, as too many denominations will become expensive to load & store each time the account is modified. See issues "),a("a",{attrs:{href:"https://github.com/cosmos/cosmos-sdk/issues/5467",target:"_blank",rel:"noopener noreferrer"}},[e._v("5467"),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"https://github.com/cosmos/cosmos-sdk/issues/4982",target:"_blank",rel:"noopener noreferrer"}},[e._v("4982"),a("OutboundLink")],1),e._v(" for additional context.")]),e._v(" "),a("p",[e._v("Simply rejecting incoming deposits after a denomination count limit doesn't work, since it opens up a griefing vector: someone could send a user lots of nonsensical coins over IBC, and then prevent the user from receiving real denominations (such as staking rewards).")]),e._v(" "),a("h2",{attrs:{id:"decision"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#decision"}},[e._v("#")]),e._v(" Decision")]),e._v(" "),a("p",[e._v("Balances shall be stored per-account & per-denomination under a denomination- and account-unique key, thus enabling O(1) read & write access to the balance of a particular account in a particular denomination.")]),e._v(" "),a("h3",{attrs:{id:"account-interface-x-auth"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#account-interface-x-auth"}},[e._v("#")]),e._v(" Account interface (x/auth)")]),e._v(" "),a("p",[a("code",[e._v("GetCoins()")]),e._v(" and "),a("code",[e._v("SetCoins()")]),e._v(" will be removed from the account interface, since coin balances will now be stored in & managed by the bank module.")]),e._v(" "),a("p",[a("code",[e._v("SpendableCoinsVestingAccount()")]),e._v(" and "),a("code",[e._v("TrackDelegation()")]),e._v(" will be altered to take a bank keeper and a denomination as two additional arguments, which will be used to lookup the balances from the base account as necessary.")]),e._v(" "),a("p",[e._v("Vesting accounts will continue to store original vesting, delegated free, and delegated vesting coins (which is safe since these cannot contain arbitrary denominations).")]),e._v(" "),a("h3",{attrs:{id:"bank-keeper-x-bank"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bank-keeper-x-bank"}},[e._v("#")]),e._v(" Bank keeper (x/bank)")]),e._v(" "),a("p",[a("code",[e._v("GetBalance(addr AccAddress, denom string) sdk.Coin")]),e._v(" and "),a("code",[e._v("SetBalance(addr AccAddress, coin sdk.Coin)")]),e._v(" methods will be added to the bank keeper to retrieve & set balances, respectively.")]),e._v(" "),a("p",[e._v("Balances will be stored first by the address, then by the denomination (the reverse is also possible, but retrieval of all balances for a single account is presumed to be more frequent):")]),e._v(" "),a("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"ZnVuYyBCYWxhbmNlS2V5KGFkZHIgc2RrLkFjY0FkZHJlc3MsIGRlbm9tIHN0cmluZykgW11ieXRlIHsKICByZXR1cm4gYXBwZW5kKGFwcGVuZChCYWxhbmNlS2V5UHJlZml4LCBhZGRyLkJ5dGVzKCkuLi4pLCBbXWJ5dGUoZGVub20pLi4uKQp9Cg=="}}),e._v(" "),a("p",[a("code",[e._v("DelegateCoins()")]),e._v(" and "),a("code",[e._v("UndelegateCoins()")]),e._v(" will be altered to take a single "),a("code",[e._v("sdk.Coin")]),e._v(" (one denomination & amount) instead of "),a("code",[e._v("sdk.Coins")]),e._v(", since they should only operate on one denomination. They will read balances directly instead of calling "),a("code",[e._v("GetCoins()")]),e._v(" (which no longer exists).")]),e._v(" "),a("p",[a("code",[e._v("SubtractCoins()")]),e._v(" and "),a("code",[e._v("AddCoins()")]),e._v(" will be altered to read & write the balances directly instead of calling "),a("code",[e._v("GetCoins()")]),e._v(" / "),a("code",[e._v("SetCoins()")]),e._v(" (which no longer exist).")]),e._v(" "),a("p",[a("code",[e._v("trackDelegation()")]),e._v(" and "),a("code",[e._v("trackUndelegation()")]),e._v(" will be altered to read & write the balances directly instead of calling "),a("code",[e._v("GetCoins()")]),e._v(" / "),a("code",[e._v("SetCoins()")]),e._v(" (which no longer exist).")]),e._v(" "),a("p",[e._v("External APIs will need to scan all balances under an account to retain backwards-compatibility - additional methods should be added to fetch a balance for a single denomination only.")]),e._v(" "),a("h3",{attrs:{id:"supply-module"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#supply-module"}},[e._v("#")]),e._v(" Supply module")]),e._v(" "),a("p",[e._v("The supply module, in order to implement the total supply invariant, will now need to scan all accounts & call "),a("code",[e._v("GetBalance")]),e._v(" using the "),a("code",[e._v("x/bank")]),e._v(" Keeper for the denomination in question, then sum the balances and check that they match the expected total supply.")]),e._v(" "),a("h2",{attrs:{id:"status"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#status"}},[e._v("#")]),e._v(" Status")]),e._v(" "),a("p",[e._v("Proposed.")]),e._v(" "),a("h2",{attrs:{id:"consequences"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#consequences"}},[e._v("#")]),e._v(" Consequences")]),e._v(" "),a("h3",{attrs:{id:"positive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#positive"}},[e._v("#")]),e._v(" Positive")]),e._v(" "),a("ul",[a("li",[e._v("O(1) reads & writes of balances (with respect to the number of denominations for which an account has non-zero balances)")])]),e._v(" "),a("h3",{attrs:{id:"negative"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#negative"}},[e._v("#")]),e._v(" Negative")]),e._v(" "),a("ul",[a("li",[e._v("Slighly less efficient reads/writes when reading & writing all balances of a single account in a transaction.")])]),e._v(" "),a("h3",{attrs:{id:"neutral"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#neutral"}},[e._v("#")]),e._v(" Neutral")]),e._v(" "),a("p",[e._v("None in particular.")]),e._v(" "),a("h2",{attrs:{id:"references"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),a("p",[e._v("Ref https://github.com/cosmos/cosmos-sdk/issues/4982\nRef https://github.com/cosmos/cosmos-sdk/issues/5467\nRef https://github.com/cosmos/cosmos-sdk/issues/5492")])],1)}),[],!1,null,null,null);t.default=s.exports}}]);